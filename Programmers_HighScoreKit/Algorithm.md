# 1. Greedy
1) 정의 ( 탐욕 알고리즘 )
 - 미래를 고려하지 않고, 현재 시점에서 가장 좋은 선택
 - 정렬을 사용해서 문제 해결

<br>

2) 특징  
   (1) 현재의 최적 해 != 전체의 최적 해  
   - 근사 알고리즘  
   - 최적해가 보장되는 조건에서만 그리디 알고리즘 사용
   
   (2) 그리디 알고리즘 사용조건
   - 현재의 선택이 미래의 선택에 영향을 주지 않을 때
   - 부분의 최적해가 모이면 전체의 최적해가 됨
   
   (3) DP 보다 속도가 빠름  
     -> 완전탐색은 단순무식하게 정답을 찾는 방식 : 너무 느림  
     -> 개선하려고 DP 사용  
     -> DP 도 항상 최적해를 보장하기 위해 모든 경우의 수 고려함  
     -> DP 도 느림  
     -> 100% 최적해를 보장해야 되지 않는 경우에 대해서 그리디 알고리즘이 만들어짐

<br>

3) 예제(백준)  
 (1) 브론즈  
 : 세탁소사장동혁(2720), 전자레인지(10162), 거스름돈(5585), 캠핑(4796), 컵홀더(2810)  <br><br>
 (2) 실버  
 : 설탕배달(2839), ATM(11399), 동전0(11047), 잃어버린 괄호(1541), 회의실 배정(1931)  <br><br>
 (3) 골드  
 : 강의실 배정(11000), 카드 정렬하기(1715), 단어 수학(1339), 수묶기(1744), 보석도둑(1202)

<br><br>

# 2. HASH
1) 정의
- Key-Value 를 가지는 자료구조
- ex. 전화번호부  
  Key : 무언가를 찾기위한 검색어 ( ex.이름 )  
  Value : 검색어로 나온 결과 ( ex.전화번호 )

2) 특징  
   (1) 모든 데이터 타입으로 접근 가능  
   (2) 언제 써야 하는가 : String 기반(Key)으로 정보를 기록/관리 할 때

3) 예제(프로그래머스)  
  (1) 완주하지 못한 선수(42576) : 선수이름이 key  
  (2) 신고결과 받기(92334)  
  (3) 의상(42578)

4) 방법
- 생성  
  -  HashMap<String, Boolean> map = new HashMap<>();
- 입력  
  -  map.put("a", true) ( map["a"] = true )
- 읽기1  
  - map.get("a") ( map["a"] )  
    : "a"라는 key 없을 시 에러
- 읽기2  
  - map.getOrDefault("a", false)  
 : "a"라는 key 에 값이 있으면 a의 value 반환, 없으면 false 반환


<br><br><br><br>
# 99. 다시 풀어보기  
1. 프로그래머스  
- 체육복(42862) : Set, 배열 2가지 방법으로 생각하기
2. BOJ